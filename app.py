import streamlit as st
from components.pokemon_gallery import mostrar_galeria_pokemon_paginada, mostrar_tipos_pokemon 
import os
import pandas as pd
from torchvision.transforms.functional import to_pil_image
from PIL import Image

from prod.models.utils import (
    load_dataset,
    load_model,
    generate_by_neighbors_image,
    buscar_imagen_por_nombre,
    interpolar_pokemon_por_nombre,
    generate_representative_pokemon,
    generate_multiple_by_neighbors
)

st.set_page_config(page_title="Generador de Pok√©mon Aleatorios", page_icon="üß¨")

@st.cache_resource
def get_model():
    return load_model()

@st.cache_data
def get_dataset():
    return load_dataset()

@st.cache_data
def get_tipos(_dataset):
    return sorted(list(set([str(label) for _, label, _ in _dataset])))

def main():
    dataset = get_dataset()
    model = get_model()
    tipos = get_tipos(dataset)

    df = pd.read_csv("data/pokemon.csv")
    rows = df.to_dict(orient="records")

    # T√≠tulo principal con √≠cono
    st.title("üß¨ Generador de Pok√©mon Aleatorios")

    # Descripci√≥n persuasiva con "autom√°gicamente" destacado
    st.markdown(
        """
        Deja volar tu imaginaci√≥n generando todos los Pok√©mon que quieras.  </br></br>
        <span style="font-size: 27px;"><b>Generar Pok√©mon: </b></span>Selecciona uno de nuestra lista, elegi la cantidad de pok√©mon a combinar y generaremos uno <span style="font-size: 22px;"><b>autom√°gicamente ‚ú®</b></span> </br></br>
        <span style="font-size: 27px;"><b>Generar Multi Pok√©mon: </b></span>Selecciona uno de nuestra lista, elegi la cantidad de pok√©mon que debe tener en cuenta para crear y generaremos 4 Pok√©mon <span style="font-size: 22px;"><b>nuevos ‚ú®</b></span> </br></br>
        <span style="font-size: 27px;"><b>Interpolar Pok√©mon: </b></span>Selecciona dos de nuestra lista y te mostraremos como los <span style="font-size: 22px;"><b>combinamos üîÄ</b></span> de a poco </br></br>
        <span style="font-size: 27px;"><b>Generar representativo: </b></span>Selecciona un tipo de nuestra lista y te generaremos el <span style="font-size: 22px;"><b>Pok√©mon representativo del tipo elegido üéâ‚Äã‚Äã</b></span> </br>
        
        Descubr√≠ nuevas combinaciones, explor√° criaturas que jam√°s imaginaste y compart√≠ tus creaciones con amigos.  
        Esta app es perfecta para fans, jugadores y entrenadores que buscan inspiraci√≥n, diversi√≥n o nuevos retos.
        """,
        unsafe_allow_html=True  # Permite usar HTML
    )

    st.subheader("Selecciona tu Pok√©mon favorito")
    folder = "data/pokemon/"
    images = sorted([os.path.join(folder, f) for f in os.listdir(folder) if f.lower().endswith((".png", ".jpg", ".jpeg"))])
    if "page_number" not in st.session_state:
        st.session_state["page_number"] = 0
    if "selected_pokemon" not in st.session_state:
        st.session_state["selected_pokemon"] = []
    lang_dict = {
        "select": "Seleccionar",
        "previous": "<--",
        "next": "-->",
        "pagination": "P√°gina {current} de {total}",
        "selected": "Seleccionados",
    }

    mostrar_galeria_pokemon_paginada(
        images=images,
        page_number=st.session_state["page_number"],
        images_per_page=8,
        images_per_row=4,
        pokemon_rows=rows,
        lang_dict=lang_dict,
    )

    lang_dict = {
        "select_type": "Selecciona un tipo de Pok√©mon",
        "type_selected": "Tipo seleccionado"
    }

    mostrar_tipos_pokemon(dataset, lang_dict, tipos)

    # Obtener selecci√≥n actual
    seleccionados = st.session_state.get("selected_pokemon", [])
    seleccion_tipo = st.session_state.get("tipo_seleccionado")

    # Cambiar de tipo a Pok√©mon
    if len(seleccionados) in [1, 2] and st.session_state.get("modo_actual") != "pokemon":
        st.session_state["tipo_seleccionado"] = None
        st.session_state["modo_actual"] = "pokemon"
        st.rerun()

    # Cambiar de Pok√©mon a tipo
    elif seleccion_tipo and st.session_state.get("modo_actual") != "tipo":
        st.session_state["selected_pokemon"] = []
        st.session_state["modo_actual"] = "tipo"
        st.rerun()

    # Mostrar botones seg√∫n cantidad seleccionada
    if len(seleccionados) == 1:
        k = st.number_input("Cantidad de Pok√©mon a combinar", min_value=1, max_value=10, value=2, step=1)
        if st.button("‚ú® Generar Pok√©mon ‚ú®"):
            nombre = seleccionados[0]
            gen_img, neighbor_names = generate_by_neighbors_image(
                model, dataset, nombre, device=None, k=int(k)
            )
            st.success(f"¬°Tu Pok√©mon generado a partir de {nombre} est√° listo!")
            st.image(to_pil_image(gen_img), caption="Pok√©mon generado", use_container_width=True)

            st.markdown("### üß¨ Vecinos utilizados para generar el Pok√©mon:")
            cols = st.columns(len(neighbor_names))
            for i, name in enumerate(neighbor_names):
                with cols[i]:
                    ruta_imagen = buscar_imagen_por_nombre(name)
                    if ruta_imagen and os.path.exists(ruta_imagen):
                        st.image(Image.open(ruta_imagen), caption=name, use_container_width=True)
                    else:
                        st.warning(f"No se encontr√≥ imagen para: {name}")

        if st.button("‚ú® Generar Multi Pok√©mon ‚ú®"):
            nombre = seleccionados[0]
            generated_imgs, neighbor_names = generate_multiple_by_neighbors(model, dataset, nombre, k=int(k), num_outputs=4)
            st.markdown("### üé® Pok√©mon generados:")
            cols = st.columns(len(generated_imgs))
            for i, img in enumerate(generated_imgs):
                with cols[i]:
                    st.image(img, caption=f"Generado #{i+1}", use_container_width=True)

            st.markdown("### üß¨ Vecinos utilizados para generar los Pok√©mon:")
            cols = st.columns(len(neighbor_names))
            for i, name in enumerate(neighbor_names):
                with cols[i]:
                    ruta_imagen = buscar_imagen_por_nombre(name)
                    if ruta_imagen and os.path.exists(ruta_imagen):
                        st.image(Image.open(ruta_imagen), caption=name, use_container_width=True)
                    else:
                        st.warning(f"No se encontr√≥ imagen para: {name}")

    elif len(seleccionados) == 2:
        st.info("Se seleccionaron dos Pok√©mon. Pod√©s interpolarlos.")
        if st.button("üîÄ Interpolar Pok√©mon"):
            st.success(f"¬°Listo para interpolar entre {seleccionados[0]} y {seleccionados[1]}!")
            interpolados = interpolar_pokemon_por_nombre(model, dataset, seleccionados[0], seleccionados[1], steps=20)

            st.markdown("### üîÄ Interpolaci√≥n entre Pok√©mon seleccionados")
            for i in range(0, len(interpolados), 5):
                cols = st.columns(min(5, len(interpolados) - i))
                for j, img_tensor in enumerate(interpolados[i:i+5]):
                    with cols[j]:
                        st.image(to_pil_image(img_tensor), width=150, caption=f"Paso {i + j + 1}")

    elif seleccion_tipo:
        st.info("Se seleccion√≥ un tipo de Pok√©mon. Pod√©s crear uno nuevo de ese tipo.")
        if st.button("üéâ Generar Pok√©mon representativo üéâ"):
            st.success(f"¬°Listo para generar un Pok√©mon de tipo {seleccion_tipo}!")
            img_supremo = generate_representative_pokemon(model, dataset, seleccion_tipo)
            if img_supremo:
                st.image(img_supremo, caption=f"Pok√©mon del tipo {seleccion_tipo}", use_container_width=True)
            else:
                st.warning("No se pudieron generar im√°genes para ese tipo.")
    else:
        if len(seleccionados) > 2:
            st.warning("Por favor, seleccion√° solo 1 o 2 Pok√©mon.")

if __name__ == "__main__":
    main()

# streamlit run app.py
# python -m streamlit run app.py